# 二叉树

## 二叉树先序遍历

[144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

递归实现：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        return dfs(root,new ArrayList<Integer>());
    }
    public List<kInteger> dfs(TreeNode root,List<Integer> res){
        if(root == null)return res;
        res.add(root.val);
        dfs(root.left,res);
        dfs(root.right,res);
        return res;
    }
}
```

非递归实现:

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if(root != null){
            Stack<TreeNode> s = new Stack<>();
            s.push(root);
            while(!s.isEmpty()){
                TreeNode cur = s.pop();
                ans.add(cur.val);
                if(cur.right != null){
                    s.push(cur.right);
                }
                if(cur.left != null){
                    s.push(cur.left);
                }
            }
        }
        return ans;
    }
}
```

## 二叉树中序遍历

[94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

递归实现：

```java

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        return dfs(root,new ArrayList<Integer>());
    }
    List<Integer> dfs(TreeNode root,List<Integer> res){
        if(root == null){
            return res;
        }
        dfs(root.left,res);
        res.add(root.val);
        dfs(root.right,res);
        return res;
    }
}
```

非递归实现：

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if(root != null){
            Stack<TreeNode> s = new Stack<>();
            while(!s.isEmpty() || root != null){
                if(root != null){
                    s.push(root);
                    root = root.left;
                }else{
                    TreeNode cur = s.pop();
                    res.add(cur.val);
                    root = cur.right;
                }
            }
        }
        return res;
    }
}
```

## 二叉树后序遍历

[145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

递归实现

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        return dfs(root,new ArrayList<Integer>());
    }
    List<Integer> dfs(TreeNode root,List<Integer> res){
        if(root == null){
            return res;
        }
        dfs(root.left,res);
        dfs(root.right,res);
        res.add(root.val);
        return res;
    }
}
```

非递归实现

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root != null){
            Stack<TreeNode> s = new Stack<>();
            TreeNode prev = null;
            while(!s.isEmpty() || root != null){
                while(root != null){
                    s.push(root);root = root.left;
                }
                TreeNode cur = s.peek();
                if(cur.right == null || cur.right == prev){
                    res.add(cur.val);//
                    s.pop();
                    prev = cur;
                }else{
                    root = cur.right;
                }
            }
        }
        return res;
    }
}
```

## 二叉树层序遍历

[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root != null){
            Queue<TreeNode> q = new LinkedList<>();
            q.offer(root);
            while(!q.isEmpty()){
                int n = q.size();
                List<Integer> arr = new ArrayList<>(n);
                for(int i = 0;i < n;i++){
                    TreeNode cur = q.poll();
                    if(cur.left != null)q.offer(cur.left);
                    if(cur.right != null)q.offer(cur.right);
                    arr.add(cur.val);
                }
                res.add(arr);
            }
        }
        return res;
    }
}
```

## 二叉树最大宽度

[662. 二叉树最大宽度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-width-of-binary-tree/description/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    static final int MAX_LEN = 3333;
    static TreeNode[] nq = new TreeNode[MAX_LEN];//队列
    static int head,tail;
    static int[] iq = new int[MAX_LEN];//队列元素对应下表
    public int widthOfBinaryTree(TreeNode root) {
        int ans = 0;
        if(root != null){
            head = tail = 0;
            nq[tail] = root;
            iq[tail++] = 0;
            while(head < tail){
                ans = Math.max(ans,iq[tail  - 1] - iq[head] + 1);
                int n = tail - head;
                for(int i = 0;i < n;i++){
                    TreeNode now = nq[head];
                    int now_ind = iq[head++];
                    if(now.left != null){
                        nq[tail] = now.left;
                        iq[tail++] = now_ind * 2 + 1;
                    }
                    if(now.right != null){
                        nq[tail] = now.right;
                        iq[tail++] = now_ind * 2 + 2;
                    }
                }
            }
        }
        return ans;    
    }
}
```

## 判断平衡二叉树

[LCR 176. 判断是否为平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/description/)

```java
class Solution {
    
    public boolean isBalanced(TreeNode root) {
        return dfs(root) != -1;
    }
    public int dfs(TreeNode root){
        if(root == null)return 0;
        int l = dfs(root.left);
        if(l == -1)return -1;
        int r = dfs(root.right);
        if(r == -1)return -1;
        if(Math.abs(r - l) > 1)return -1;
        return Math.max(l,r) + 1;
    }
}
```

## 二叉树最近公共祖先

[LCR 194. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q)return root;
        TreeNode l = lowestCommonAncestor(root.left,p,q);
        TreeNode r = lowestCommonAncestor(root.right,p,q);
        if(l != null && r != null)return root;
        return l == null?r:l;
    }
}
```

## 二叉树后继节点（中序遍历下一个）

x有右子树，后继节点y是右子树最左边的最后一个节点

x无右子树，x则是y的左子树最右边的节点

[LCR 053. 二叉搜索树中的中序后继 - 力扣（LeetCode）](https://leetcode.cn/problems/P5rCT8/description/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    HashMap<TreeNode,TreeNode> fa = new HashMap<>();
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        dfs(root,p,null);
        if(p.right != null){
            p = p.right;
            while(p.left != null)p = p.left;
            return p;
        }
        TreeNode parent = fa.get(p);
        while(parent != null && parent.left != p){
            p = fa.get(p);
            parent = fa.get(parent);
        }
        return parent;
    }
    public void dfs(TreeNode root,TreeNode p,TreeNode f){
        if(root == null)return;
        this.fa.put(root,f);
        dfs(root.left,p,root);
        dfs(root.right,p,root);
    }
}
```



## 二叉树的序列化和反序列化


