# 堆排序

堆（增加元素上浮（heapInsert），删除元素下浮）

## 🎯 堆排序的核心思想

1. **堆的概念**：
   
   - 堆是一颗完全二叉树。
   
   - 大根堆：任意节点的值 ≥ 子节点值。
   
   - 小根堆：任意节点的值 ≤ 子节点值。

  堆排序一般用 **大根堆**，这样每次堆顶就是当前最大值。

2. **堆排序步骤**：
   
   - **建堆**：把数组变成一个大根堆。
   
   - **交换**：把堆顶（最大值）和堆尾交换，缩小堆的范围。
   
   - **下沉**：重新调整剩余部分，使其保持大根堆性质。
   
   - 循环直到堆的范围缩小为 0。

  👉 最终数组就是升序排列。

```java

    public static void heap_sort(int[]arr,int l,int r){
        //[0-arr.length - 1]
        if(arr == null || arr.length < 2)return;
//        for(int i = 0;i < arr.length;i++){
//            heapInsert(arr,i);
//        }
        for(int i = arr.length - 1;i >= 0;i--){
            heapify(arr,i,arr.length);
        }
        int heapSize = arr.length;
        swap(arr,--heapSize,0);
        while (heapSize > 0){
            heapify(arr,0,heapSize);
            swap(arr,0,--heapSize);
        }
    }
    public static void  heapInsert(int[]arr,int ind){//ind >= 0
        while(arr[(ind - 1) / 2] < arr[ind]){
            swap(arr,(ind - 1) / 2,ind);
            ind = (ind - 1) / 2;
        }
    }
    public static void heapify(int[]arr,int ind,int heapSize){
        int l = ind * 2 + 1;
        while (l < heapSize){
            l = l + 1 < heapSize && arr[l]  < arr[l + 1] ? l + 1 :l  ;
            l = arr[ind] < arr[l]?l:ind;
            if(l == ind)break;
            swap(arr,ind,l);
            ind = l;
            l = ind * 2 + 1;
        }
    }
```

## 复杂度

- **建堆**：O(n)

- **每次调整**：O(log n)，共 n-1 次

- **整体复杂度**：O(n log n)，不需要额外空间

##### 堆排序是原地、不稳定、时间复杂度 O(n log n) 的排序算法


