# 基数排序

## 🚀 基数排序 + 桶排序的核心思想

1. 找出数组里最大的数，看它有几位数（比如 802 → 3 位）。

2. 从 **个位 → 十位 → 百位…**，逐位进行 **稳定的桶排序**。(这里基数为10)

3. 每一轮保证根据当前位有序，最终整体有序。

```java
    public static void radixSort(int[]arr,int l,int r){
        //[l-r]
        if(arr == null || arr.length < 2)return;
        __radixSort(arr,l,r,maxDigit(arr,l,r));
    }
    public static int maxDigit(int[]arr,int l,int r){
        int max = arr[l];
        for(int i = l + 1;i <= r;i++){
            max = Math.max(max,arr[i]);
        }
        int res = 0;
        while(max > 0){
            res++;
            max /= 10;
        }
        return res;
    }
    public static void __radixSort(int[]arr,int l,int r,int digit){
        final int radix = 10;
        int[]bucket = new int[r - l + 1];
        int i = 0,j = 0;
        for(int t = 0;t < digit;t++){
            int[]count = new int[radix];//分片作用,前缀和
            for(i = l;i <= r;i++){
                j = getDigit(arr[i],t);
                count[j] += 1;
            }
            for(i = 1;i < radix;i++){
                count[i] += count[i - 1];
            }
            for(i = r;i >= l;i--){
                j = getDigit(arr[i],t);
                bucket[count[j] - 1] = arr[i];
                count[j]--;
            }
            for(i = l;i <= r;i++){
                arr[i] = bucket[i - l];
            }
        }
    }
    public static int getDigit(int x,int k){
        return (int)(x / Math.pow(10,k)) % 10;
    }
    public static boolean check(int[] arr, int l, int r){
        //[l,r]
        for(int i = l;i < r;i++){
            if(arr[i] > arr[i + 1])return false;
        }return true;
    }


```

- **基数排序**：多轮桶排序（按位排序）。

- **桶排序**：用计数数组记录频次 + 前缀和确定位置。

- **稳定性**：倒序放回桶，保证相同位的数相对顺序不乱





- **时间复杂度**：O(d·n)，d = 最大位数

- **空间复杂度**：O(n)

- **稳定性**：稳定排序

- **适用场景**：适合整数、位数不太多的情况，尤其是当 n 很大时，它可能比 O(n log n) 的比较排序（快排、堆排、归并）更快。
