# 归并排序（时间复杂度:（ N * logN ）,空间复杂度：O（N））

## 🟢 归并排序的核心思想

一句话总结：  
**“分而治之”** —— 把数组一分为二，递归排序左右两边，再把两个有序的部分合并成一个有序的整体。

---

## 🟡 步骤拆解

1. **分**：把数组从中间劈开，变成左右两半。

2. **治**：递归地对左右两半分别排序。

3. **合**：把排好序的两半“合并”成一个有序数组。

## 代码：

```java
public void merge_sort(int[]arr,int l,int r){//(l-r)
    if(l >= r)return;
    int mid = l + ((r - l) >> 1);
    merge_sort(arr,l,mid);
    merge_sort(arr,mid + 1,r);
    merge(arr,l,r,mid);
}
public void merge(int[]arr,int l,int r,int mid){
    int[]temp = new int[r - l + 1];
    int x = l,y = mid + 1,c = 0;
    while(x <= mid && y <= r){
        temp[c++] = arr[x] <= arr[y]?arr[x++]:arr[y++];
    }
    while(x <= mid){
        temp[c++] = arr[x++];
    }
    while(y <= r){
        temp[c++] = arr[y++];
    }
    for(int i = 0;i < c;i++){
        arr[l + i] = temp[i];
    }
}
```

### 习题

###### 5.1.1（小和问题）

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个给定数组的小和。

例子：数组为：[1,3,4,2,5]

1左边比1小的数：没有

3左边比3小的数：1

4左边比4小的数：1,3

2左边比2小的数：1

5左边比5小的数：1,3,4,2

所以小和为1+(1+3)+1+(1+3+4+2)=16

```java
public int merge_sort(int[]arr,int l,int r){//(l-r)
    if(l >= r)return 0;
    int mid = l + ((r - l) >> 1);
    int res = 0;
    res += merge_sort(arr,l,mid);
    res += merge_sort(arr,mid + 1,r);
    res += merge(arr,l,r,mid);
    return res;
}
public int merge(int[]arr,int l,int r,int mid){
    int[]temp = new int[r - l + 1];
    int res = 0,x = l,y = mid + 1,c = 0;
    while(x <= mid && y <= r){
        if(arr[x] == arr[y])temp[c++] = arr[x++];
        else if(arr[x] < arr[y]){
            temp[c++] = arr[x];
            res += arr[x ++] * (r - y + 1);
        }else{
            temp[c++] = arr[y++];
        }
    }
    while(x <= mid){
        temp[c++] = arr[x++];
    }
    while(y <= r){
        temp[c++] = arr[y++];
    }
    for(int i = 0;i < c;i++){
        arr[l + i] = temp[i];
    }
    return res;
}
```

###### 5.1.2（逆序对问题）（[LCR 170. 交易逆序对的总数 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/)）

代码:

```java
class Solution {
    public int reversePairs(int[] record) {
        int n = record.length - 1;
        return merge_sort(record,0,n);
    }
    public int merge_sort(int[]arr,int l,int r){//(l-r)
        if(l >= r)return 0;
        int mid = l + ((r - l) >> 1);
        return merge_sort(arr,l,mid) + merge_sort(arr,mid + 1,r) + merge(arr,l,r,mid);
    }
public int merge(int[]arr,int l,int r,int mid){
    int[]temp = new int[r - l + 1];
    int res = 0;
    int x = l,y = mid + 1,c = 0;
    while(x <= mid && y <= r){
        if(arr[x] <= arr[y]){
            temp[c++] = arr[x++];
        }else{
            res += mid - x + 1;
            temp[c++] = arr[y++];
        }

    }
    while(x <= mid){
        temp[c++] = arr[x++];
    }
    while(y <= r){
        temp[c++] = arr[y++];
    }
    for(int i = 0;i < c;i++){
        arr[l + i] = temp[i];
    }//if (c >= 0) System.arraycopy(temp, 0, arr, l, c);
    return res;
}
}
```
