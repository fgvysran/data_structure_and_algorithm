# 链表

## 题目1：反转链表

链接：[92. 反转链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list-ii/description/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if(right - left + 1 <= 1)return head;
        ListNode x = new ListNode();
        x.next = head;
        ListNode h = head,pre = x;
        for(int i = 0;i + 1 < left;i++){
            pre = pre.next;
            h = h.next;
        }
        ListNode res = reverseN(h,right - left + 1);
        pre.next = res;
        return x.next;
    }
    ListNode reverseN(ListNode head, int n) {
        ListNode pre = null,cur = head;
        while(n-- > 0){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
            if(n == 0)head.next = next;
        }
        return pre;
    }
}
```

## 题目2：链表深拷贝

链接:[138. 随机链表的复制 - 力扣（LeetCode）](https://leetcode.cn/problems/copy-list-with-random-pointer/description/)

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        if(head == null)return null;
        Node cur = head;
        while(cur != null){
            Node copyCur = new Node(cur.val);
            Node next = cur.next;
            cur.next = copyCur;
            copyCur.next = next;
            cur = next;
        }
        cur = head;
        while(cur != null){
            Node next = cur.next.next,copyCur = cur.next;
            copyCur.random = cur.random == null ? null : cur.random.next;
            cur = next;
        }
        cur = head;Node res = cur.next;
        while(cur != null){
            Node copyCur = cur.next,next = cur.next.next;
            cur.next = next;
            copyCur.next = next == null?null:next.next;
            cur = next;
        }
        return res;
    }
}
```

## 题目3：回文链表(快慢指针)

链接:[LCR 027. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/aMhZSa/description/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode fast = head,low = head;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            low = low.next;
        }
        ListNode t = reverse(low);
        ListNode cur = t;
        boolean f = true;
        while(cur != null && head != null){
            if(cur.val != head.val){
                f = false;break;
            }
            cur = cur.next;head = head.next;
        }
        //t = reverse(t);
        return f;
    }
    public ListNode reverse(ListNode h){
        ListNode pre = null,cur = h;
        while(cur != null){
            ListNode next = cur.next;
            cur.next = pre;
            if(next == null)break;
            pre = cur;
            cur = next;
        }
        return cur;
    }
}
```

## 题目4：分割链表

链接:[面试题 02.04. 分割链表 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-list-lcci/description/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        if(head == null)return head;
        ListNode ah = null,ae = null,bh = null,be = null;
        while(head != null){
            ListNode next = head.next;
            head.next = null;
            if(head.val < x){
                if(ah == null){
                    ah = ae = head;
                }else{
                    ae.next = head;ae = ae.next;
                }
            }else{
                if(bh == null){
                    bh = be = head;
                }else{
                    be.next = head;
                    be = be.next;
                }
            }
            head = next;
        }
        if(ah == null){
            return bh;
        }else{
            ae.next = bh == null?null:bh;
            return ah;
        }
    }
}
```

## 题目5：相交链表（两个无环）

链接:[160. 相交链表 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int n = 0;
        ListNode a = headA,b = headB;
        while(a.next != null){
            n++;a = a.next;
        }
        while(b.next != null){
            n--;b = b.next;
        }
        a = n < 0?headB:headA;
        b = a == headA?headB:headA;
        n = n < 0?-n:n;
        while(n-- > 0)a = a.next;
        while(a != b){
            a = a.next;b = b.next;
        }
        return a;
    }
}
```

## 题目6：环形链表

链接：[LCR 022. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/c32eOV/description/)

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null)return head;
        ListNode fast = head,low = head;
        while(fast.next != null && fast.next.next != null){
            fast = fast.next.next;
            low = low.next;
            if(fast == low)break;
        }
        if(fast.next == null || fast.next.next == null)return null;
        fast = head;
        while(fast != low){
            fast =  fast.next;
            low = low.next;
        }
        return fast;
    }
}
```
